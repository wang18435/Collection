目前的技术存在的问题
    （1）一个项目就是一个工程
        如多项目庞大，不适合用package划分模块，最好每一个模块对应一个工程
    借助Maven将一个项目拆分成多个功能
    （2）项目中的jar包必须手动“复制”“粘贴”到WEB/INF/lib目录下
        同样的jar文件重复出现在不同的项目工程中，浪费空间且工程臃肿
        借用Maven把jar包保存在“仓库”中
    （3）jar包需要准备好，或到官网下载
        通过Maven提供下载
    （4）一个jar包依赖的其他jar包需要手动加入到项目中
        spring-core依赖commons-logging
        spring-context spring-aop  aopliance ....
----------------------------------------------------------------------------------------------------------------------------------------------------------------------——
Maven构建的概念
    Maven服务于java的自动构建工具（自身也是使用Java写的）
编译
    编译
    部署
    搭建
        编译：编译为字节码
        部署：BS项目最终运行的并不是动态web工程本身，而是动态工程编译的过程
        动态web工程编译结果才能执行
    运行时环境：其实是一组jar包的引用，并没有把jar复制到工程中，所以并不是目录
构建过程：
（1）清理：将以前编译得到的旧的字节码文件删除，为下一次编译做准备
（2）编译：将java源文件编译成class文件
（3）测试：自动测试
（4）报告：测试程序执行的结果
（5）打包：动态Web工程打war包，java工程打jar包
（6）安装：Maven特定概念，将打包的得到的文件复制到仓库中的指定位置
（7）部署：将动态Web工程生成的war包复制在Servley容器的指定目录下，使其可以运行
自动化构建：
----------------------------------------------------------------------------------------------------------------------------------------------------------------------——
安装Maven核心程序
    （1）检查java_home环境变量
    （2）解压Maven核心程序的压缩包
mvn -v 查看配置是否成功
----------------------------------------------------------------------------------------------------------------------------------------------------------------------——
Maven约定的目录结构
    约定的目录结构*
    Hello
    |---src
    |---|---main
    |---|---|---java
    |---|---|---resource
    |---|---test
    |---|---|---java
    |---|---|---resource
    |---pom.xml

    (1)根目录
    （2）src 源码
    （3）pom.xml Maven 工程的核心配置文件
    （4）main 存放主程序
    （5）test 存放测试程序
    （6）java Java源文件
    （7）resource 存放框架配置文件或其他工具的配置文件
    
    为什么遵守约定的目录结构
    Maven负责这个项目的自动化构建，以编译为例，Maven要想自动进行编译，它必须知道java源文件报讯在哪里
    
    如果我们自己自定义的东西想要让框架或工具知道，有两种方式
        已配置的方式明确告诉框架
        遵守内部开发已经存在的约定
        （约定大于配置，配置大于编码）
----------------------------------------------------------------------------------------------------------------------------------------------------------------------——
常用maven命令
    1 注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录
        与构建过程相关：编译，测试，打包、。。。。
        maven -v 并不是与构建过程相关的命令
        常用命令
            （1）Mvn clean 清理M
             (2)mvn compile 编译主程序
            （3）mvn test-compile 编译测试程序
            （4）mvn test 执行测试
            （5）mvn package 打包
             (6)mvn site 生成项目
            （7）mvn install 安装在仓库中
----------------------------------------------------------------------------------------------------------------------------------------------------------------------——
关于联网问题
    （1）Maven的核心程序仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。
    （2）当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先在本地仓库中查找。
    （3）本地仓库中的位置：【系统用户当前目录的家目录 ~\.m2\repository】
     配置文件中可查看下载的位置
     <!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   | Default: ${user.home}/.m2/repository
  <localRepository>/path/to/local/repo</localRepository>
    （4）Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网（可调国内镜像），到中央仓库去下载
    （5）如果连接不到，则构建失败
    （6）修改默认的本地仓库的位置，可以让Maven核心程序到我们事先准备好的目录下查找插件
        (1)setting中配置
       （2）找到localRepository标签
       （3）将内容修改
--------------------------------------------------------------------------------------------------------------------------------------------------
打包命令只打包主程序，不打包测试程序
--------------------------------------------------------------------------------------------------------------------------------------------------
pom
（1）含义：Project Object Mode项目对象模型
            Dom （Document Object Model）
    pom.xml对于Maven是核心配置文件，与构建的一切相关配置都设置在这个文件中进行
       重要程度相当于Web.xml对于Web工程项目
-------------------------------------------------------------------------------------------------------------------------------------------------- 
坐标
数学中的坐标
    （1）在平面上使用X,Y两个向量可以唯一的定位平面的任何一个点
    （2）在空间中X,Y，Z可以唯一定位一个点
Maven坐标
    三个向量
    （1）groupId：公司或组织名倒序加项目名
        <groupid>com.xx.xx</groupid>
        本来应该是xx.com
    （2）artifactid
        模块名称
        <artifactid>Hello</artifactid>
    （3）version
        该项目的版本
     版本
    坐标与路径中的对应关系
    <groupid>org.springframe</groupid>
    <artifactid>spring-core</artifactid>
    <version>4.0.0 RELEASE</version>
    org/springframe/spring-core/4.0.0

     三者结合定位一个Maven工程
    公司（xx.xom）里找项目（xx），项目里找模块（Hello）
--------------------------------------------------------------------------------------------------------------------------------------------------
Maven仓库
    （1）本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有的Maven工程服务
    （2）远程仓库：
        （1）局域网范围：（私服）：Nexus 有私服先去私服找（找不到私服连外网，然后保存在私服上）
        （2）中央仓库：架设在Intenet上，为所有的Maven工程服务
        （3）中央仓库的镜像：架设在各个大洲，为中央仓库分流，减轻中央仓库的压力，同时更快地响应用户请求
            （1）Maven自身需要的插件
            （2）第三方jar包或工具的jar包（第一方jdk，第二方自己）
            （3）我们自己开发的Maven工程
--------------------------------------------------------------------------------------------------------------------------------------------------
第二个Maven工程
    Maven解析依赖信息会去本地仓库中去查找被依赖的jar包
    对于我么自己开发的mvn工程，使用install命令后就可以进入仓库 
    注：出现错误，未标注package,编译时生成的target不会出问题，进行mvn install时就会影响生成的jar包
--------------------------------------------------------------------------------------------------------------------------------------------------
依赖的范围
scope标签，例
<scope>compile</scope>
<scope>test</scope>
常用的有三个取值，compile，test，provided
compile
    对主程序是够有效：有效
    对测序程序是否有效：有效
    是否参与打包：参与

test
    对主程序是够有效：无效
    对测序程序是否有效：有效
    是否参与打包：不参与
    例子：junit
上两个根据程序结构
provided
    从程序的开发阶段认识，与compile进行对比
        开发，部署，运行，compile在三个阶段都会使用，provided在开发时需要，开发时没有tomcat的支持，部署的时候被忽略，，运行时服务器可以提供，由Servlet
        容器提供（通常是Servlet Api）

    对主程序是够有效：有效
    对测序程序是否有效：有效
    是否参与打包：不参与（最关键，不参与部署）
    例子：servlet Api

Maven程序由两部分，分别为main和test（在src下），有compile的依赖，有test的依赖，compile对主程序是可见的，对test也是可见的，test仅对测试程序有效，打包仅对主程序有效，
因为测试程序不参与打包
--------------------------------------------------------------------------------------------------------------------------------------------------
Maven生命周期插件和目标
生命周期：
    （1）各个环节执行的顺序:不能打乱顺序，按照既定的顺序执行
    （2）Maven核心程序中定义了抽象的生命周期，生命周期中和各个阶段的任务是由插件来完成的
    （3）Maven为了更好地实现自动化构建，按照这一特定的特点执行生命周期中的各个阶段：不论现在要执行在生命周期哪一个阶段，都是从这个生命周期最初的位置开始执行
        从在命令行中的执行过程中可以看出

Maven有三套独立的生命周期，分别是：
（1）Clean Lifecycle在进行真正的构建之前进行一系列的清理工作
（2）Deafult Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等
（3）Site Lifecycle生成项目报告，站点，发布站点

Clean生命周期分为三个阶段：
    pre-clean:执行之前做的准备工作
    clean：移除上一次构建生成的文件
    post-clean：执行一些需要在clean之后立刻完成的工作

Site生命周期
    （1）pre-site执行一些需要在生成站点文档之前的工作
    （2）site 生成项目的站点文档
    （3）post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
     (4)site-deploy 将生成的站点文档部署到特定的服务器上
        这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，manager比较喜欢，文档及统计数据自动生成
        命令： mvn site

Deafult
    最重要的的一个
    处理复制资源文件
    编译
    复制并处理资源文件，至目标测试目录，编译测试源代码
    编译测试源代码
    测试
    打包 
    打包的准备
    安装 
    将最终的包复制到远程仓库

 插件和目标：
    （1）在生命周期的各个阶段仅仅定义了要执行的任务是什么》
    （2）各个阶段和插件的目标是对应的。
    （3）相似的目标由特定的插件来完成
生命周期阶段  |    插件目标         |插件
compile         compile               maven-compiler-plugin
test-compile    testCompile           maven-compiler-plugin

可以将目标看做调用插件功能的命令
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
在Eclipse中的操作
 windows-perferences
 注意的： 
    （1）Maven插件：ecplise中已经内置
    （2）maven插件的设置：
            installations：指定Maven核心程序的位置，不建议使用插件自带的Maven自带的Maven程序，默认embedded
            user settings：自定setting.xml的位置，以及仓库的位置
    （3）基本操作
        （1）创建Maven版的java工程
        （2）创建Maven版的Web工程
        （3）执行Maven命令
在ecplise里区分项目的方法是通过打包的方式来区分的，默认是jar包
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
重要度
    目录结构*
    pom*
    坐标*
    依赖**
    仓库
    生命周期/插件/目标
    继承
    聚合